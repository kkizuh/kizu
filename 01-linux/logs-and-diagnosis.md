# Диагностика Linux: top/htop/btop, iostat/pidstat, dmesg, journalctl

## 0) Быстрый TRIAGE (60–120 сек)

```bash
uptime                  # load average: общая нагрузка (CPU+I/O+пр.)
free -h                 # RAM/Swap остаток
df -hT                  # место на дисках
top -H -o %CPU          # кто жрёт CPU (threads)
iostat -xz 1            # узкое место по дискам (каждую сек)
journalctl -p err..alert -n 200   # свежие системные ошибки
```

Если **CPU** не 100%, а **load** высокий → часто **I/O** (disk/net) или много процессов в состоянии **D**.

---

## 1) top — везде есть, быстрый взгляд

Запуск:

```bash
top               # базово
top -H            # показать треды (threads)
top -H -o %CPU    # сразу сорт по CPU
```

### Горячие клавиши (во время top)

- **P** — сорт по %CPU
- **M** — сорт по памяти
- **T** — сорт по времени CPU (TIME+)
- **N** — сорт по PID
- **1** — показать все ядра (пер-CPU)
- **c** — показывать полную командную строку
- **H** — треды on/off
- **i** — скрыть idle-процессы (удобно при шуме)
- **k** — kill (ввести PID, затем сигнал, напр. `15` или `9`)
- **f** — выбрать поля (метрики)
- **o** — переупорядочить поля
- **S** — кумулятивное время (с момента старта) on/off
- **W** — сохранить конфиг (чтобы сорт/поля помнились)

### Что смотреть
- Строка `Cpu(s)`: **us** (user), **sy** (kernel), **ni**, **id**, **wa** (I/O wait), **st** (steal в VM).
- Если **wa** стабильно > 20% → тормозит I/O.

---

## 2) htop — удобная интерактивщина

```bash
htop
```

### Суперполезные клавиши

- **F6** — выбрать колонку сортировки (**%CPU**, **MEM%**, **TIME+**, **IO_RATE** если включить)
- **F5** — дерево процессов (tree)
- **F3** — поиск по имени процесса
- **F4** — фильтр по имени (оставляет только совпадения)
- **u** — отфильтровать по пользователю
- **I** — инвертировать порядок сортировки (asc/desc)
- **H** — показать/скрыть треды
- **K** — скрыть kernel threads
- **F7/F8** — изменить приоритет nice
- **F9** — kill (выбор сигнала)
- **F2** — Settings →
    - **Meters**: добавь CPU per-core, **I/O rate**, **IO-wait**
    - **Display options**: включи **“Detailed CPU time”** (видно steal/guest/IOwait)


> Хочешь видеть I/O в таблице процессов? В **F2 → Columns** добавь `IO_RATE`, `IO_READ_RATE`, `IO_WRITE_RATE`.

---

## 3) btop — новый уровень визуалки (оч удобно)

Установи из репо (часто есть как `btop`) и запусти:

```bash
btop
```

### Навигация и ключевые хоткеи (минимально нужно)

- **h** — помощь/справка с хоткеями (очень полезно)
- **Tab** — переключение между виджетами (CPU/MEM/DISK/NET/PROC)
- **↑/↓** — перемещение по списку процессов
- **Enter** — показать детали процесса
- **f** — фильтр по имени процессов
- **s** — выбрать сортировку (откроется меню: **CPU%**, **MEM%**, **TIME+**, **IO**, **PID**, **COMMAND**)
- **r** — реверс сортировки (asc/desc)
- **t** — дерево процессов (toggle)
- **k** — kill (выбор сигнала)
- **+/-** — изменить приоритет (nice)
- **z** — “pause update” (заморозить обновление, чтобы внимательно посмотреть)
- **B** — выбор темы/цветов (не критично, но приятно)

> Лайфхак: нажми **h** → “Keybindings” и запомни **s/r/t/f**. Этого хватает на каждый день.

---

## 4) iostat / pidstat / iotop — кто грузит диски

### iostat (из пакета `sysstat`) — главное про диски

```bash
iostat -xz 1
```

- **%util** — насколько диск занят временем (под 100% = узкое место)
- **r/s, w/s** — IOPS чтение/запись
- **rkB/s, wkB/s** — throughput
- **await** — средняя латентность (мс) запроса (чем выше — тем хуже)
- **avgqu-sz** — длина очереди (ожидание)

**Диагноз:** `%util≈100%` + `await↑` → диск не успевает → ищем виновников.

### pidstat — кто именно грузит

```bash
pidstat -dl 1        # по дисковой активности (read/write per PID, latency)
pidstat -u 1         # по CPU
pidstat -r 1         # по памяти (Major/Minor faults)
```

### iotop — top по I/O

```bash
sudo iotop -oP
# -o   показывать только процессы с активным IO
# -P   показывать процессы (не треды)
```

---

## 5) dmesg — ядро/железо/критика

```bash
dmesg -T | tail -n 100
dmesg -T | egrep -i 'error|fail|fatal|oom|i/o|ext4|nvme|blk' | tail -n 200
```

Ищем:
- **OOM-killer** (Out Of Memory) — значит, память кончалась
- **I/O errors** / **EXT4-fs error** — проблема с диском/ФС
- драйверы (сетевые/дисковые), паники

---

## 6) journalctl — логи systemd и сервисов

```bash
journalctl -p err..alert -n 200      # ошибки по системе
journalctl -b                        # с текущей загрузки
journalctl --since "1 hour ago"      # окно времени

journalctl -u nginx -f               # follow конкретного юнита
journalctl -u my.service -p err -n 100
journalctl _PID=1234 -n 100          # по PID
journalctl -t sudo -n 100            # по тэгу (COMM)
```

Полезно:

```bash
journalctl --disk-usage
sudo journalctl --vacuum-time=14d     # чистка старых логов
# сделать persistent:
sudo mkdir -p /var/log/journal && sudo systemd-tmpfiles --create --prefix /var/log/journal
sudo systemctl restart systemd-journald
```

---

## 7) Сетевые быстрые

```bash
ss -tulpn               # кто слушает порты
ss -s                   # сводка TCP
sudo lsof -i :5432      # кто занял порт 5432
```

---

## 8) “Комбухи” — готовые сценарии действий

### A) Высокий load, CPU не 100% → подозрение на I/O

1. `top` → нажми **1** (все ядра), **P/M** (сорт), **H** (треды): есть ли процесс(ы), висящие в **D**?
2. `iostat -xz 1` → смотри `%util`, `await`, `rkB/s,wkB/s`.
3. `pidstat -dl 1` или `iotop -oP` → выясни PID виновника.
4. Дальше по ситуации: снизить параллелизм, включить кеш/буфер, перенести на NVMe/другой диск.

### B) Память заканчивается / своп жрётся
1. `free -h` → есть ли свободно/available? Своп растёт?
2. `top` → **M** сортировка по памяти; **VIRT/RES** большие?
3. `pidstat -r 1` → кто ловит major faults (идёт в своп)?
4. `dmesg` → был ли OOM-killer и кого убил.
5. Фиксы: лимиты сервису, уменьшить кэши, пересмотреть конфиги JVM/DB, добавить RAM, временно своп-файл.

### C) Сервис “не стартует”, прав хватает

1. `journalctl -u сервис -b` → текст ошибки.
2. `dmesg -T | grep -i deny` и **SELinux/AppArmor** (смотри твою шпору):
    - SELinux: `ausearch -m avc -ts recent` / `sealert -a /var/log/audit/audit.log`
    - AppArmor: `journalctl -k | grep DENIED`, `aa-status`

### D) “Всё подлагивает”, но CPU/RAM норм

1. `top` → **wa** (IO-wait) вверху; если >20% стабильно — диск.
2. `iostat -xz 1` → подтверждение
3. Смотри к/в сеть: `ss -s`, `sar -n DEV 1` (если есть `sysstat`).

### E) “Кто держит порт/файл?”

```bash
sudo lsof -i :443
sudo fuser -v 443/tcp
sudo lsof /var/log/my.log
```

---

## 9) Мелочи, которые часто спасают

- В `top` включи **c** (полные команды) и **1** (все ядра) — сразу яснее картина.
- В `htop` добавь I/O-колонки: **F2 → Columns → IO_RATE** и друзья.
- В `btop` жми **s** и сортируй по **IO** или **MEM%** в зависимости от ситуации.
- `vmstat 1` — быстрый общий “пульс”: `r` (run queue), `si/so` (swap), `wa` (I/O wait)
- Журнал делай **persistent** (см. выше) — иначе после ребута логи теряются.

---

## 10) Мини-FAQ (коротко)

- **Что значит load 20 при 8 CPU?** Может быть норм при высоком I/O. Смотри `wa`, `iostat`.    
- **Как понять, кто жрёт NVMe?** `iostat -xz 1` + `iotop -oP`/`pidstat -dl 1`.
- **Как сохранить настройки top/htop?** top — **W**. htop — F2 → Save.
- **Как быстро убить “залипший” процесс?** В `htop` выдели → **F9** → `SIGKILL (9)` (сначала лучше 15).
- **Где искать “почему рестартится юнит”?** `journalctl -u my.service | grep -i restart`.
