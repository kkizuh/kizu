ок, делаю версию «чуть подробнее, но всё ещё по-человечески». Сохрани это как `uid-gid-basics.md`.

---

# UID/GID — «почему файл мой, а доступ не мой»

## 0) Зачем мне это знать?

- ФС хранит **цифры** (UID/GID), а не имена.
- Доступ к файлам решается по **совпадению чисел**, а не «как зовут пользователя».
- В контейнерах/томах это особенно видно: внутри один UID, на хосте другой → «Permission denied».

---

## 1) Термины простыми словами

- **UID** — User ID (номер пользователя). `root = 0`. Остальные — 1..∞
- **GID** — Group ID (номер группы).
- **Владелец** файла = UID, **группа** файла = GID.
- Права `rwx` применяются по тройке: **u** (owner), **g** (group), **o** (others).

Посмотреть быстро:

```bash
id                # кто я: uid/gid и группы
stat -c '%U %G %u %g %A %n' file   # имя/имя и номера + права
ls -l             # человекочитаемо, но без номеров
getent passwd     # таблица «имя ↔ uid»
getent group      # таблица «имя ↔ gid»
```

---

## 2) Где задаются правила «какие ID считаем системными»

- `/etc/login.defs`: `UID_MIN`, `GID_MIN`. Часто:
    - системные аккаунты ≈ `1–999` (или 1–9999),
    - «обычные» юзеры — **с 1000+**.
- В своих сервисах/контейнерах бери **фиксированные** `10001:10001` — редко конфликтует.

Создать сервисного юзера с фиксированным ID:

```bash
# Debian/Ubuntu
addgroup --system --gid 10001 app
adduser  --system --uid 10001 --ingroup app --home /srv/app --shell /usr/sbin/nologin app

# Alpine
addgroup -S -g 10001 app
adduser  -S -u 10001 -G app -h /srv/app -s /sbin/nologin app
```

---

## 3) Как решается доступ к файлу (алгоритм)

1. Если **процесс EUID** (эффективный UID) = **владелец файла** → применяем «u: rwx».
2. Иначе, если **любой GID процесса** = **группа файла** → применяем «g: rwx».
3. Иначе → применяем «o: rwx».
4. Плюс учитываются **ACL** (если есть) и **capabilities** для некоторых операций.

Проверка по шагам (чек-лист):

```bash
# 1) кто процесс?
id

# 2) кто файл?
stat -c '%u %g %a %A %n' /path/file

# 3) есть ли ACL?
getfacl /path/file 2>/dev/null | sed -n '1,20p'

# 4) монт-опции/SELinux?
mount | grep ' /path '
getenforce 2>/dev/null
```

---

## 4) «Почему файл в общей папке от группы?» — про setgid и sticky

- **setgid на директории** (`chmod g+s dir`):  
    новые файлы **наследуют GID директории**, а не текущей «первичной группы» процесса.  
    → удобно для «общих» рабочих папок команды.
- **sticky bit** на директории (`chmod +t dir`):  
    удалить файл может **только владелец файла** (или root), даже если у папки `rwx` для всех.
    → `/tmp` работает именно так.

Паттерн «общая папка для команды»:

```bash
groupadd team
mkdir -p /srv/shared
chgrp team /srv/shared
chmod 2775 /srv/shared       # 2 = setgid, rwxrwxr-x
setfacl -m g:team:rwx /srv/shared   # (опц.) ACL, если нужны тонкие доступы
```

---

## 5) setuid / setgid на файлах (понимать, но редко трогать)

- **setuid** (`chmod u+s file`): процесс при запуске получает **EUID владельца файла**.  
    Пример: `/usr/bin/sudo` владеет root, запускаешь обычным — процесс становится EUID=0.
- **setgid** на файлах — аналогично для EGID.

> На проде руками не разбрасывай `u+s` — это дыра, если неправильно.

---

## 6) UID/GID и контейнеры (Docker/Podman/K8s)

- В контейнере процесс — это **процесс ядра хоста** с **числовым UID**.
- **Bind mount/volume**: права берутся **с хоста**.
    - Внутри ты `USER 10001`, на хосте том принадлежит `uid=1000` → Permission denied.
    - Фиксы:
        - выровнять владельца на хосте: `sudo chown -R 10001:10001 /data`,
        - в Dockerfile класть артефакты с владельцем: `COPY --chown=10001:10001 . /app`,
        - запускать: `docker run --user 10001:10001 ...`,
        - при SELinux: `-v /data:/data:Z` или `:z`.
- **Distroless**: нет пакетного менеджера, юзера не добавить → юзай `USER 65532` (готовый nonroot).
- **Порты <1024** (80/443) без root:
    - слушай высокий порт в контейнере `8080`, а наружу маппь `-p 80:8080`, или
    - выдай бинарю capability:
```bash
        setcap 'cap_net_bind_service=+ep' /app/mybin
```

Мини-скелет Dockerfile:

```Dockerfile
FROM debian:bookworm-slim
RUN addgroup --system --gid 10001 app \
 && adduser --system --uid 10001 --ingroup app --home /app --shell /usr/sbin/nologin app
WORKDIR /app
COPY --chown=10001:10001 . .
USER 10001:10001
ENTRYPOINT ["./app"]
```

---

## 7) ACL — когда «u/g/o» не хватает

- Позволяют дать доступ **конкретным** пользователям/группам без смены владельца.
- Пример: «добавь группе `qa` только чтение на файл»:

```bash
setfacl -m g:qa:r /srv/reports/report.csv
getfacl /srv/reports/report.csv
```

- **Default ACL** на директорию — шаблон для новых файлов:
```bash
setfacl -m d:g:team:rwx /srv/shared
```

---

## 8) Почему «имена» ломаются при переносе дисков

- ФС хранит **UID/GID как числа**.
- На новой системе имя `www-data` может иметь **другой UID**, чем на старой.
- После переноса тома видишь «почему-то `1001:1001`» — потому что у этой системы так мапится.  
    **Вывод**: опирайся на **числа**, а не на имена. Проверяй `getent passwd`/`group`.

---

## 9) Разруливаем типовые боли (пошагово)

### Кейc А: «Контейнер не может писать в смонтированный каталог»

1. `id` внутри контейнера → видишь, под кем он (например, 10001).
2. На хосте: `stat -c '%u:%g %n' /data` → владелец 1000:1000.
3. Решение:
    - `sudo chown -R 10001:10001 /data`, или
    - запусти с `--user 1000:1000` (если ок), или
    - используй общую группу: `chgrp team /data && chmod 2775 /data && usermod -aG team <uid>`.

### Кейc B: «В общей папке новые файлы не разделяются по группе»

- Проверь `chmod g+s /srv/shared`.
- Проверь, что все участники в группе `team`: `id user`.
- При необходимости — default ACL: `setfacl -m d:g:team:rwx /srv/shared`.

### Кейc C: «Сервису нужен порт 80, но мы не root»

- Слушай 8080 в приложении, пробрось `-p 80:8080`, **или** `setcap 'cap_net_bind_service=+ep' /app/bin`.

### Кейc D: «После миграции сервера права поехали»

- Сверь `getent passwd | grep -E 'app|nginx|www-data'` на старом и новом.
- Выставь такие же **UID/GID**, либо `chown -R new_uid:new_gid` на данных.

---

## 10) Команды, которые реально нужны каждый день

```bash
# кто я, какие группы
id

# кто владелец (имена и номера), права:
stat -c '%U:%G (%u:%g) %A (%a) %n' path

# сменить владельца/группу (по номерам — надёжнее)
chown 10001:10001 -R /srv/app

# сделать совместную папку (наследовать группу)
chgrp team /srv/shared
chmod 2775 /srv/shared

# дать группе доступ через ACL
setfacl -m g:team:rwx /srv/shared
getfacl /srv/shared | head

# быстро увидеть проблемы с «доступ запрещён» (audit на SELinux-системах)
ausearch -m avc -ts recent 2>/dev/null | tail
```

---

## 11) Мини-FAQ

**Можно ли просто `USER 10001` и не создавать юзера?**  
	Да. Процесс запустится под этим UID. Но не будет домашней, имени, и иногда тулзы офигевают. Лучше создать системного пользователя и выровнять владельцев.

**Почему `ls -l` показывает имена, а не цифры?**  
	Потому что оно мапит через `/etc/passwd`/`group`. Покажи цифры: `ls -ln` или `stat`.

**Почему в контейнере `root` — это плохо?**  
	Если приложение скомпрометируют, root внутри может злоупотреблять kernel/sysfs/cgroups/драйверами, особенно при неправильных настройках. Запускай **не root** и давай только нужные capabilities.

**ACL vs chmod/chown?**  
	`chmod/chown` — база. ACL — «точечно добавить доступ» без смены владельца/группы. В командах `cp/rsync` следи за `-p`/`-a`, чтобы ACL сохранялись.

